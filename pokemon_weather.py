# -*- coding: utf-8 -*-
"""Pokemon Weather

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18-84ogLVE50Mz_MMRtWxceAcdS2Jd-xs
"""

# initilization of everything to make sure it works right with the libraries needed to preform actions, use images, and helps the apis
# shout out to tomScott who made a unique video about apis and their history which made me aware of them, heres the link https://www.youtube.com/watch?v=BxV14h0kFs0
import random
from PIL import Image
import requests
from io import BytesIO
import matplotlib.pyplot as plt

# these are the lists of pokemon based on their individual weather conditions
  #i could theoretically grab a pokemon based on both their type and weight from the api so I wouldn't have to have the list but it's fine for now
sunny_and_hot = ["Charizard", "Arcanine", "Flareon", "Magmar", "Rapidash", "Moltres"]
clear_no_cloud = ["Ninetales", "Butterfree", "Dodrio", "Aerodactyl"]
partly_cloudy_mostly_sunny = ["Ivysaur", "Venusaur", "Sandslash", "Kangaskhan", "Eevee", "Rhyhorn", "Exeggutor"]
cloudy_mostly_cloudy = ["Bulbasaur", "Wartortle", "Poliwhirl", "Gloom", "Vaporeon", "Tangela"]
overcast = ["Slowpoke", "Slowbro", "Hypno", "Jigglypuff", "Wigglytuff", "Farfetch’d", "Lickitung"]
fog_mist = ["Haunter", "Gengar", "Gastly", "Dratini", "Dragonair", "Alakazam"]
rain = ["Blastoise", "Starmie", "Golduck", "Seaking", "Poliwrath", "Kingler", "Omastar"]
thunderstorm = ["Jolteon", "Electabuzz", "Raichu", "Magneton", "Zapdos"]
snow = ["Dewgong", "Cloyster", "Jynx"]
sleet = ["Tentacruel", "Seadra", "Shellder", "Kabutops"]
freezing_rain = ["Onix", "Graveler", "Golem"]
blizzard = ["Articuno", "Snorlax", "Lapras"]
haze_smoke = ["Koffing", "Weezing", "Grimer", "Muk", "Cubone", "Marowak", "Ekans", "Arbok"]
windy = ["Pidgeotto", "Doduo", "Fearow", "Scyther"]


# Function to determine pokemon based on weather; not sure if I can clean this up as it's a beheamoth

def assign_pokemon(condition):
    if condition == "HOT":
        return random.choice(sunny_and_hot)
    elif condition == "CLEAR":
        return random.choice(clear_no_cloud)
    elif condition == "PARTLY CLOUDY":
        return random.choice(partly_cloudy_mostly_sunny)
    elif condition == "CLOUDY":
        return random.choice(cloudy_mostly_cloudy)
    elif condition == "OVERCAST":
        return random.choice(overcast)
    elif condition == "FOG":
        return random.choice(fog_mist)
    elif condition == "WET":
        return random.choice(rain)
    elif condition == "THUNDERSTORM":
        return random.choice(thunderstorm)
    elif condition == "SNOW":
        return random.choice(snow)
    elif condition == "SLEET":
        return random.choice(sleet)
    elif condition == "FREEZING RAIN":
        return random.choice(freezing_rain)
    elif condition == "BLIZZARD":
        return random.choice(blizzard)
    elif condition == "HAZE":
        return random.choice(haze_smoke)
    elif condition == "WINDY":
        return random.choice(windy)
    else:
        return "Unknown Pokémon"  # Fallback; i should add the bugged pokemon

# poke api (what i use to grab the pokemon's images) stuff to grab images of pokemon & assign to the day
def get_pokemon_image(pokemon_name):
  # this takes the pokemon that was chosen and plugs them into the api to get their image
    poke_api_url = f"https://pokeapi.co/api/v2/pokemon/{pokemon_name.lower()}"
    response = requests.get(poke_api_url)
    if response.status_code == 200:
        pokemon_data = response.json()
        return pokemon_data["sprites"]["front_default"]  # URL of the Pokémon's front sprite
    else:
      # this is a fallback if there's issues; it won't be needed but it's good to have, following the trend of the rest of my code to prevent bugs
        return None

#the states coordinantes asigned when you enter them in; theres probaly a better awy to do it. ill resarch later because I don't have time rn and it does what it needs to. Trend of bodginess as i like to call it
state_coordinates = {
    "Alabama": (32.8067, -86.7915),
    "Alaska": (61.3704, -152.4044),
    "Arizona": (33.7298, -111.4312),
    "Arkansas": (34.9697, -92.3731),
    "California": (36.1162, -119.6816),
    "Colorado": (39.0598, -105.3111),
    "Connecticut": (41.5978, -72.7554),
    "Delaware": (39.3185, -75.5071),
    "Florida": (27.7663, -81.6868),
    "Georgia": (33.0406, -83.6431),
    "Hawaii": (21.0943, -157.4983),
    "Idaho": (44.2405, -114.4788),
    "Illinois": (40.3495, -88.9989),
    "Indiana": (39.8494, -86.2583),
    "Iowa": (42.0115, -93.2105),
    "Kansas": (39.0639, -98.3859),
    "Kentucky": (37.6681, -84.6701),
    "Louisiana": (31.1695, -91.8671),
    "Maine": (44.6939, -69.3814),
    "Maryland": (39.0639, -76.8021),
    "Massachusetts": (42.2302, -71.5301),
    "Michigan": (43.3266, -84.5361),
    "Minnesota": (45.6945, -93.9002),
    "Mississippi": (32.7416, -89.6787),
    "Missouri": (37.9643, -91.8318),
    "Montana": (46.9219, -110.4544),
    "Nebraska": (41.4925, -99.9018),
    "Nevada": (38.3135, -117.0554),
    "New Hampshire": (43.4525, -71.5639),
    "New Jersey": (40.2989, -74.5210),
    "New Mexico": (34.8405, -106.2485),
    "New York": (42.1657, -74.9481),
    "North Carolina": (35.6301, -79.8064),
    "North Dakota": (47.5289, -99.7840),
    "Ohio": (40.3888, -82.7649),
    "Oklahoma": (35.5653, -96.9289),
    "Oregon": (43.9335, -120.5583),
    "Pennsylvania": (40.5908, -77.2098),
    "Rhode Island": (41.6809, -71.5118),
    "South Carolina": (33.8569, -80.9450),
    "South Dakota": (44.2998, -99.4389),
    "Tennessee": (35.7478, -86.6924),
    "Texas": (31.0545, -97.5635),
    "Utah": (40.1500, -111.8624),
    "Vermont": (44.0459, -72.7107),
    "Virginia": (37.7693, -78.1699),
    "Washington": (47.4009, -121.4905),
    "West Virginia": (38.4913, -80.9543),
    "Wisconsin": (43.7844, -88.7879),
    "Wyoming": (42.7559, -107.3025),
}

# this code here is mainly to grab the state through a user input and grab the cordinantes i assigned to each state earlier and generate an api link that can be used

while True: # a loop to ensure they don't enter something wrong that'll break the program entirley
  # this is the user input for their state; it pulls from the list I established earlier. There's probaly an eaiser way to get cordinantes or get zip codes to assign stuff but right now im too tired.
      # note to self for later: national weather service uses an api itself to grab the locations so maybe I should resarch that
  state_input = input("Enter a state name: ")

  # this fetches the coordinates based on user input
  if state_input in state_coordinates:
      latitude, longitude = state_coordinates[state_input]
      # this is the url that we made and the api draws from (we used lists to make it, see state_coordinantes); it assignes the state's lattitudes and longtiudes
      url = f"https://api.weather.gov/points/{latitude},{longitude}"

      # Data is requested from the api through the url we now created
      response = requests.get(url)

      # this is a check if the code was sucessful; it's repeated throughout my code numerous times as a failsafe
      if response.status_code == 200:
          data = response.json()

          # Get's the forecast url (a url from inside the points url above) from the earlier created link; it's done in a way to allow us to enter lattitude and longitude while I can avoid using a really bad url method where I'd have to make executive decisons on locations of National weather service offices
          forecast_url = data['properties']['forecast']

          # Requests data from the new forecast URL we created
          forecast_response = requests.get(forecast_url)

          if forecast_response.status_code == 200:
            # data 2 is the data from the forecast url we grabbed; it holds the information so we wont use the normal 'data' we created earlier
            data2 = forecast_response.json()
            break
          else:
              print("Error retrieving forecast data.")
      else:
          print("Error retrieving state point data.")
  else:
      print("Invalid state name. Please enter a valid state.\nRemember, it's case sensitive!")
# these are obviously error codes; I should add images later of wrenches to show it's broken from the pokemon games (as we have that from the url) but I'd have to call on pokeapi twice and this project is big enough as it is

# this variable controls the period we choose (wether its today or tonight)
  # starts at 0(today) and 1 is later in the day
theDate = 0
# this is some code that allows us to draw the individual period from data2 to get that individual time
periods = data2['properties']['periods']

# Main loop to get forecast data and determine the pokemon and stop it from going to more than 2(periods)
while theDate < 2:
    # Fetch the forecast data based on the current value of theDate
    forecast = periods[theDate]  # Update forecast for each period in the loop

    # Weather information that's pulled and reported
    day = forecast['name']  # Access the name for the current period
    weather = forecast['detailedForecast']
    temperature = forecast['temperature']
    temperature_unit = forecast['temperatureUnit']
    wind_speed = forecast['windSpeed']
    wind_direction = forecast['windDirection']
    precipitation_probability = forecast['probabilityOfPrecipitation']['value']

    def get_weather_condition(weather_description):
      if "sunny" in weather_description.lower():
        return "HOT"
      if "clear" in weather_description.lower():
        return "CLEAR"
      if "rain" in weather_description.lower() or "showers" in weather_description.lower():
        if "freezing" in weather_description.lower():
          return "FREEZING RAIN"
        else:
            return "WET"
      if "snow" in weather_description.lower() or "snowy" in weather_description.lower():
          return "SNOW"
      if "cloudy" in weather_description.lower():
        if "partly" in weather_description.lower():
          return "PARTLY CLOUDY"
        elif "mostly" in weather_description.lower():
          return "CLOUDY"
        else:
          return "OVERCAST"
      if "fog" in weather_description.lower() or "mist" in weather_description.lower():
          return "FOG"
      if "thunderstorm" in weather_description.lower():
          return "THUNDERSTORM"
      if "sleet" in weather_description.lower():
          return "SLEET"
      if "haze" in weather_description.lower() or "smoke" in weather_description.lower():
          return "HAZE"
      if "windy" in weather_description.lower():
          return "WINDY"
      else:
          return "MILD"  # Default
    # Get conditions for today or tonight
    today_condition = get_weather_condition(weather)

    # Assign Pokémon based on the weather condition
    pokemon = assign_pokemon(today_condition)
    pokemon_image_url = get_pokemon_image(pokemon)

    # This displays information such as the weather and the pokemon assigned
    print(f"{day} in {state_input} expect {weather}\n")
    print(f"Assigned Pokémon: {pokemon}\n")

    # Fetch the image from the URL we and display it
    response = requests.get(pokemon_image_url)
    img = Image.open(BytesIO(response.content))
    plt.imshow(img)
    plt.axis('off')  # theres these really weird axes that took way too long to hide and without this itll look off
    plt.show()
    print()

    # adds to the date to proceed to next period; its put at the end so the while greater than works well
    theDate += 1